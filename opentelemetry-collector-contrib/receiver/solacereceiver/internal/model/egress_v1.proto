syntax = "proto3";

package solace.messaging.proto.broker.trace.egress.v1;

// Messages with the following topic contain a message matching this
// specification:
// _telemetry/broker/trace/egress/v1[/additional/topic/levels]
// Note that the topic allows for additional topic levels to be added in the
// future. Receiving clients must not assume there are no additional topic
// levels.
//
// This message describes telemetry data that a Solace PubSub+ broker captures
// in the egress portion of its data path.
//
// Fields with names that end in "time_unix_nano" are 64-bit timestamps, in
// nanoseconds, since midnight, Jan. 1, 1970 UTC.
//
message SpanData {

  repeated EgressSpan egress_spans = 1;

  // The router-name of the broker generating this message at the time the
  // message was generated.
  string router_name = 2;

  // The broker's message-vpn name. This field may be removed in the future
  // without a major version change since the field is specified as optional.
  //
  // Rather than rely on this field, receiving clients should obtain the VPN
  // by using an SMF API to extract the VPN_NAME_IN_USE from the API's Session
  // object. The message_vpn_name of all messages received from via an SMF
  // API's session will match the session's VPN_NAME_IN_USE.
  optional string message_vpn_name = 3;

  // The SolOS version of the broker generating the message. All elements of
  // egress_spans will always have been created by the same broker version.
  string solos_version = 4;

  message EgressSpan {
    // 16-byte globally unique trace ID. Any two spans with the same trace ID
    // are part of the same trace.
    bytes trace_id = 1;

    // 8-byte span ID, unique within the scope of a trace.
    bytes span_id = 2;

    // If not present, this is a root span. If present, this is an 8-byte span
    // ID of the parent span.
    optional bytes parent_span_id = 3;

    // The start and end timestamps of the receive span. The start of the span
    // is when Guaranteed Messaging processing begins in the broker.
    sfixed64 start_time_unix_nano = 4;
    sfixed64 end_time_unix_nano = 5;

    optional TransactionEvent transaction_event = 6;
    optional string error_description = 7;

    oneof type_data {
      SendSpan send_span = 8;
    }
  }

  // This message contains information unique to a SendSpan.
  message SendSpan {

    // The name of the queue or topic endpoint the message is being delivered
    // from.
    oneof source {
      string queue_name = 1;
      string topic_endpoint_name = 2;
    }

    Outcome outcome =  3;

    bool replayed_msg = 4;

    string consumer_client_username = 5;
    string consumer_client_name = 6;
    string protocol = 7;
    optional string protocol_version = 8;

    enum Outcome {
      ACCEPTED = 0;
      REJECTED = 1;
      RELEASED = 2;
      DELIVERY_FAILED = 3;
      FLOW_UNBOUND = 4;
      TRANSACTION_COMMIT = 5;
      TRANSACTION_COMMIT_FAILED = 6;
      TRANSACTION_ROLLBACK = 7;
    }
  }

  // When a span has a transaction event, it indicates the span occurs as part
  // of processing a transaction, and includes the *current* state of of the
  // transaction when the event was generated. The state can change as
  // subsequent events occur as part of the transaction.
  message TransactionEvent {
    sfixed64 time_unix_nano = 1;
    enum Type {
      // COMMIT and ROLLBACK are always initiated by either a CLIENT or ADMIN.
      // The initiator is ADMIN when the management interface is used to
      // to perform a heuristic commit or rollback.
      COMMIT = 0;
      ROLLBACK = 1;
      // PREPARE and END can only occur with a CLIENT initiator, and spans for
      // these operations are only generated if the operation fails. Therefore,
      // the error_description of the TransactionEvent will always be present
      // for END and PREPARE.
      END = 2;
      PREPARE = 3;

      // The initiator of a SESSION_TIMEOUT is always BROKER. All messages
      // received as part of the transaction are discarded.
      SESSION_TIMEOUT = 4;

      // The initiator of ROLLBACK_ONLY is always BROKER. The first such event
      // in a transaction always has an error_description in the span,
      // indicating there was a problem processing the message when it was
      // received, and the message is being discarded. This also transitions
      // the transaction itself to a "rollback only" state, which causes
      // all subsequent messages received as part of the transaction to also
      // be discarded. Spans generated by these subsequent discards will not
      // have the span's error_description set, but all ROLLBACK_ONLY
      // transaction events will have an error_description set, which indicate
      // the transaction's error.
      //
      // Since the only record of these messages in the context of the
      // transaction has been discarded, no further span can be generated in
      // the context of a client, admin, or session timeout operation. When a
      // subsequent operation such as rollback or commit occurs on a
      // transaction marked rollback only, only messages received prior to the
      // error triggering the transition to rollback only will generate
      // receive spans.
      ROLLBACK_ONLY = 5;
    }
    Type type = 2;

    enum Initiator {
      CLIENT = 0;
      ADMIN = 1;
      BROKER = 2;
    }
    Initiator initiator = 3;

    message Xid {
      int32 format_id = 1;
      bytes branch_qualifier = 2;
      bytes global_id = 3;
    }

    message LocalTransactionId {
      uint32 transaction_id = 1;
      uint32 session_id = 2;
      string session_name = 3;
    }

    oneof transaction_id {
      Xid xid = 4;
      LocalTransactionId local_id = 5;
    }

    optional string error_description = 6;
  }
}
